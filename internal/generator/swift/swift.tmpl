// Code generated by telegram-bot-api-types. DO NOT EDIT.
// Version {{.Version}}
import Foundation

public struct TelegramAPI {
    let request: (String, Codable) throws -> Data

    public init(request: @escaping (String, Codable) throws -> Data) {
        self.request = request
    }

    public class ValueWrapper<T: Codable>: Codable {
        let value: T
        init(value: T) {
            self.value = value
        }
    }

    public struct Empty: Codable {}
}
{{range .Enums}}
extension TelegramAPI {
    public enum {{.Name}}: String, Codable {
        {{- range .Values}}
        case {{ToSwiftName .}} = "{{.}}"
        {{- end}}
    }
}
{{end -}}
{{range .Types}}
extension TelegramAPI {
    /**
     * {{.Href}}  {{range .Description}}
     * {{.}}{{end}}
    */
    {{- if eq .Name "InputFile"}}
    public typealias {{.Name}} = Data
    {{- else if IsAbstractType .}}
    public indirect enum {{.Name}}: Codable {
        {{- range .Subtypes}}
        case {{ToCamelCase .}}({{.}})
        {{- end}}

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            {{- range $i, $v:= .Subtypes}}
            {{if gt $i 0}}else {{end}}if let value = try? container.decode({{$v}}.self) {
                self = .{{ToCamelCase $v}}(value)
            }
            {{- end -}} else {
                throw DecodingError.typeMismatch({{.Name}}.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for {{.Name}}"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                {{- range .Subtypes}}
                case .{{ToCamelCase .}}(let value):
                    try container.encode(value)
                {{- end}}
            }
        }
    }
    {{- else}}
    public struct {{.Name}}: Codable {
        {{- range .Fields}}
        /** {{ToTypesDoc .Types}} | {{.Description}} */
        public let {{.Name}}: {{ToFieldTypes .}}{{if .Required}}{{else}}?{{end}}
        {{- end}}

        public init({{range $i, $v := .Fields -}}{{if gt $i 0}}, {{end}}{{$v.Name}}: {{ToFieldTypes .}}{{if $v.Required}}{{else}}? = nil{{end}}{{end}}) {
            {{- range .Fields}}
            self.{{.Name}} = {{.Name}}
            {{- end}}
        }
    }
    {{- end}}
}
{{end -}}
extension TelegramAPI {
    public struct ResponseSuccess<T: Codable>: Codable {
        public let ok: Bool
        public let result: T
    }

    public struct ResponseError: Codable {
        public let ok: Bool
        public let error_code: Int
        public let description: String
    }

    public typealias SuccessWithOutData = Bool
    public typealias ResponseWithOutData = ResponseSuccess<SuccessWithOutData>
    public typealias ResponseWithMessage = ResponseSuccess<Message>
}
{{range .Methods}}
{{- if HasParams .}}
extension TelegramAPI {
    /** {{.Href}} */
    public struct {{ToPascalCase .Name}}Params: Codable {
        {{- range .Fields}}
        /** {{ToTypesDoc .Types}} | {{.Description}} */
        public let {{.Name}}: {{ToFieldTypes .}}{{if .Required}}{{else}}?{{end}}
        {{- end}}
        
        public init({{range $i, $v := .Fields -}}{{if gt $i 0}}, {{end}}{{$v.Name}}: {{ToFieldTypes .}}{{if $v.Required}}{{else}}? = nil{{end}}{{end}}) {
            {{- range .Fields}}
            self.{{.Name}} = {{.Name}}
            {{- end}}
        }
    }
}
{{end}}
extension TelegramAPI {

    public typealias {{ToPascalCase .Name}}Response = ResponseSuccess<{{UnionsTypes .Returns}}>

    /**
     * {{.Href}}{{range .Description}}
     * {{.}}{{end}}
     */
    public func {{.Name}}({{if HasParams .}}params: {{ToPascalCase .Name}}Params{{end}}) throws -> {{ToPascalCase .Name}}Response {
        let data = try request("{{.Name}}", {{if HasParams .}}params{{else}}[String: String](){{end}})
        return try JSONDecoder().decode({{ToPascalCase .Name}}Response.self, from: data)
    }
}
{{end}}